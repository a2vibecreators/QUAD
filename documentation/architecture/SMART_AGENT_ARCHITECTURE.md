# QUAD Platform - Smart Agent Architecture

**Version:** 1.0.0
**Last Updated:** December 31, 2025
**Purpose:** How smart agents generate code/SQL dynamically from analyzed repositories

---

## Core Concept

**Smart Agent = Agent MD (Rules) + AI Engine (Claude/GPT) + Repository Context**

**NOT pre-compiled code.** The agent generates everything on the fly based on:
1. **Agent MD file** (company-specific do's/don'ts)
2. **Repository analysis** (detected tech stack, patterns)
3. **User input** (plain English OR explicit commands)

---

## How It Works

### Step 1: Repository Analysis → Generate Agent MD

**Input:** Git repository URL
**Output:** Custom agent MD file with company rules

**Example (Mass Mutual):**
```bash
User: Provides https://github.com/massmutual/insurance-api

Agent analyzes:
  ✅ Detected: Spring Boot 3.2.0, PostgreSQL, Terraform, GitHub Actions
  ✅ Detected: Flyway migrations pattern (V1__*.sql)
  ✅ Detected: Docker naming: massmutual/<service>:v*
  ✅ Detected: Terraform structure: terraform/modules/, terraform/environments/

Agent generates: agent-massmutual-backend-developer.md
```

**Generated MD Content (Rules, NOT Code):**
```markdown
# Mass Mutual Backend Developer Agent

## Your Tech Stack (Detected)
- Spring Boot 3.2.0
- PostgreSQL (AWS RDS)
- Terraform (AWS us-east-1)
- Flyway migrations

## Do's
✅ ALWAYS use Flyway for database migrations
  Pattern: V{number}__{description}.sql
  Location: src/main/resources/db/migration/

✅ ALWAYS use Terraform module structure
  modules/api/, modules/database/, modules/networking/

✅ ALWAYS name Docker images
  massmutual/<service-name>:<version>

## Don'ts
❌ DON'T use Liquibase (use Flyway)
❌ DON'T deploy outside us-east-1 (cloud team manages regions)
❌ DON'T use MySQL (standard is PostgreSQL)
```

---

### Step 2: Developer Uses Agent (Two Input Modes)

**Agent loads the custom MD file** and uses it as context for all requests.

#### Input Mode A: Plain English

```
User (Plain English):
"I need to add a new table for storing insurance policies"

Agent (with Mass Mutual MD loaded):
  1. Reads MD: "ALWAYS use Flyway migrations"
  2. Reads MD: "Pattern: V{number}__{description}.sql"
  3. Reads MD: "Location: src/main/resources/db/migration/"
  4. Checks existing migrations: V1__create_users.sql, V2__create_claims.sql
  5. Generates next migration: V3__create_policies.sql

Generated (on the fly):
```

```sql
-- File: src/main/resources/db/migration/V3__create_policies.sql
-- Generated by QUAD Agent based on Mass Mutual standards

CREATE TABLE policies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id UUID NOT NULL,
    premium_amount DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_policies_customer_id ON policies(customer_id);
```

```
Agent:
"I've created V3__create_policies.sql following your Flyway migration pattern.
This follows Mass Mutual's standard:
- UUID primary key
- Timestamp for created_at
- Index on foreign key (customer_id)

Run: mvn flyway:migrate to apply."
```

---

#### Input Mode B: Explicit Command

```
User (Explicit Command):
"CREATE TABLE policies (policy_number, customer_id, premium_amount)"

Agent (with Mass Mutual MD loaded):
  1. Reads MD: "ALWAYS use Flyway migrations"
  2. Reads repository: Detects existing migrations (V1, V2)
  3. Generates: V3__create_policies.sql
  4. Adds Mass Mutual-specific columns (id UUID, created_at TIMESTAMP)
  5. Adds indexes based on detected pattern

Generated (on the fly):
```

```sql
-- Same output as Mode A
-- Agent ALWAYS follows MD rules regardless of input style
```

---

### Step 3: Agent Generates Code (Not Pre-Compiled)

**Agent generates code dynamically** by:
1. Reading agent MD rules
2. Analyzing existing codebase patterns
3. Following detected conventions
4. Generating new code that matches existing style

**Example: Generate REST API Endpoint**

```
User (Plain English):
"Add an API to get all policies"

Agent (with Mass Mutual MD loaded):
  1. Reads MD: REST pattern is /api/v1/{resource}
  2. Reads MD: Use DTOs for external communication
  3. Scans repo: Finds existing controller pattern (PolicyController.java)
  4. Scans repo: Finds DTO pattern (PolicyDTO.java)
  5. Generates code matching existing style

Generated files (on the fly):
```

**1. Controller (matches existing pattern):**
```java
// File: src/main/java/com/massmutual/insurance/controller/PolicyController.java
// Generated by QUAD Agent

@RestController
@RequestMapping("/api/v1/policies")
public class PolicyController {

    @Autowired
    private PolicyService policyService;

    @GetMapping
    public ResponseEntity<List<PolicyDTO>> getAllPolicies() {
        List<PolicyDTO> policies = policyService.findAll();
        return ResponseEntity.ok(policies);
    }
}
```

**2. Service (matches existing pattern):**
```java
// File: src/main/java/com/massmutual/insurance/service/PolicyService.java
// Generated by QUAD Agent

@Service
public class PolicyService {

    @Autowired
    private PolicyRepository policyRepository;

    public List<PolicyDTO> findAll() {
        return policyRepository.findAll()
            .stream()
            .map(this::toDTO)
            .collect(Collectors.toList());
    }

    private PolicyDTO toDTO(Policy policy) {
        PolicyDTO dto = new PolicyDTO();
        dto.setId(policy.getId());
        dto.setPolicyNumber(policy.getPolicyNumber());
        dto.setPremiumAmount(policy.getPremiumAmount());
        return dto;
    }
}
```

**3. DTO (matches existing pattern):**
```java
// File: src/main/java/com/massmutual/insurance/dto/PolicyDTO.java
// Generated by QUAD Agent

public class PolicyDTO {
    private UUID id;
    private String policyNumber;
    private BigDecimal premiumAmount;

    // Getters and setters
}
```

**4. Test (matches existing pattern):**
```java
// File: src/test/java/com/massmutual/insurance/controller/PolicyControllerTest.java
// Generated by QUAD Agent

@SpringBootTest
@AutoConfigureMockMvc
class PolicyControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldGetAllPolicies() throws Exception {
        mockMvc.perform(get("/api/v1/policies"))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }
}
```

---

## Key Points

### 1. No Pre-Compiled Code
- ❌ Agent does NOT have hardcoded templates
- ✅ Agent reads MD rules and generates code on demand
- ✅ Every company gets custom-generated code

### 2. Two Input Modes Work Identically
```
Plain English: "Add a policy table"
    ↓
Agent reads MD rules
    ↓
Generates: Flyway migration, JPA entity, controller, service, tests

Explicit Command: "CREATE TABLE policies (...)"
    ↓
Agent reads MD rules
    ↓
Generates: Same output (Flyway migration, JPA entity, etc.)
```

### 3. Agent Always Follows MD Rules
```
User: "Use MySQL for policies table"
    ↓
Agent reads MD: "❌ DON'T use MySQL (standard is PostgreSQL)"
    ↓
Agent response:
  "I cannot use MySQL as Mass Mutual's standard is PostgreSQL.
   I'll create the table using PostgreSQL instead.
   If you need MySQL for a specific reason, please contact the cloud team."
```

### 4. Agent Learns from Repository
```
Agent scans repository:
  ✅ Found: All DTOs have @JsonProperty annotations
  ✅ Found: All entities use UUID primary keys
  ✅ Found: All controllers have @Validated annotation

Generated code:
  ✅ Includes @JsonProperty
  ✅ Uses UUID primary keys
  ✅ Adds @Validated to controllers
```

---

## Example: Full Workflow

### Scenario: Mass Mutual Developer Needs New Feature

**User Input (Plain English):**
```
User: "I need to add a feature to upload policy documents (PDFs)"
```

**Agent Process:**
1. **Reads MD Rules:**
   - Storage: AWS S3 (detected from existing code)
   - File naming: `{policy-number}/{timestamp}-{filename}`
   - Database: PostgreSQL (standard)
   - API pattern: `/api/v1/{resource}`

2. **Scans Repository:**
   - Found: Existing FileUploadService.java
   - Found: AWS S3 client configuration
   - Found: JPA entity pattern with UUID primary keys

3. **Generates (on the fly):**

**A. Database Migration (Flyway):**
```sql
-- V4__create_policy_documents.sql
CREATE TABLE policy_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_id UUID NOT NULL REFERENCES policies(id),
    filename TEXT NOT NULL,
    s3_key TEXT NOT NULL,
    file_size BIGINT,
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**B. JPA Entity:**
```java
@Entity
@Table(name = "policy_documents")
public class PolicyDocument {
    @Id
    private UUID id;

    @ManyToOne
    @JoinColumn(name = "policy_id")
    private Policy policy;

    private String filename;
    private String s3Key;
    private Long fileSize;
    private Timestamp uploadedAt;
}
```

**C. REST Controller:**
```java
@PostMapping("/api/v1/policies/{policyId}/documents")
public ResponseEntity<PolicyDocumentDTO> uploadDocument(
    @PathVariable UUID policyId,
    @RequestParam("file") MultipartFile file
) {
    // Upload to S3, save metadata to DB
}
```

**D. Service Logic:**
```java
public PolicyDocumentDTO uploadDocument(UUID policyId, MultipartFile file) {
    // 1. Generate S3 key: {policy-number}/{timestamp}-{filename}
    // 2. Upload to S3
    // 3. Save metadata to policy_documents table
    // 4. Return DTO
}
```

**E. Tests:**
```java
@Test
void shouldUploadPolicyDocument() {
    // Test file upload endpoint
}
```

**Agent Response:**
```
I've generated the following for policy document upload:

1. ✅ Database migration: V4__create_policy_documents.sql
2. ✅ JPA Entity: PolicyDocument.java
3. ✅ REST Endpoint: POST /api/v1/policies/{id}/documents
4. ✅ Service: Uses existing AWS S3 client
5. ✅ Tests: PolicyDocumentControllerTest.java

Files follow Mass Mutual standards:
- Flyway migration pattern
- UUID primary keys
- AWS S3 storage (existing configuration)
- REST API pattern: /api/v1/{resource}

Run:
  mvn flyway:migrate
  mvn spring-boot:run
  curl -X POST http://localhost:8080/api/v1/policies/{id}/documents \
       -F "file=@policy.pdf"
```

---

## Review Mode (Optional)

**User can review before applying:**

```
User: "Review changes before applying"

Agent:
"Here's what I'll create. Please review:

[Shows all generated files with syntax highlighting]

Approve these changes?
  [Yes, apply all]  [No, modify]  [Cancel]
```

**If user selects "No, modify":**
```
User: "Change table name from policy_documents to policy_files"

Agent:
"Updated all references:
- Table: policy_documents → policy_files
- Entity: PolicyDocument → PolicyFile
- Controller: /documents → /files

Review again?
  [Yes, apply all]  [No, modify]  [Cancel]
```

---

## Summary

**Smart Agent Architecture:**
```
Repository Analysis
    ↓
Generate Agent MD (company-specific rules)
    ↓
Developer uses agent (plain English OR explicit commands)
    ↓
Agent reads MD rules + scans repository patterns
    ↓
Agent generates code/SQL on the fly (NOT pre-compiled)
    ↓
Output follows company standards (detected + documented in MD)
```

**Key Benefits:**
- ✅ Every company gets custom-generated code
- ✅ Works with plain English or explicit commands
- ✅ Follows company's existing patterns
- ✅ No pre-compiled templates (dynamic generation)
- ✅ Review mode available before applying changes

---

**Generated by QUAD Platform**
**Last Updated:** December 31, 2025
